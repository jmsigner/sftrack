---
title: "2. Reading in an sftrack"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{2. Reading in an sftrack}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    echo = TRUE,
    fig.width = 6,
    fig.asp = 0.7
)

```

Creating sftrack objects is relatively straight forward and can be read in a variety of ways including as a standard `data.frame`, `sf` object, or `ltraj` object (from `adehabitatLT`).  


## Loading in raw data

To create `sftrack` objects data we use the `as_sftrack()` (track) or `as_sftraj()` (trajectory) function, depending on your desired output. Both have the same arguments but differ in the way the geometry field is calculated.  

### Vector vs. data.frame inputs

`as_sftrack()/as_sftraj` accepts 2 kinds of raw data for each of the 4 required parts. Either a vector/list representing the data where length = nrow(data), or the column name where the data exists. For any `sftrack` component you can input either vector data or the column name for any variable, and can mix types between arguments.

**Vector** inputs to `as_sftrack` generally involve feeding as_sftrack the data itself where length(vector) == nrow(data). Or a list where each component adheres to this rule. If using entirely vector inputs for grouping, geometry, time, and error then `data` is not required. 

**data.frame** inputs on the other hand are simply character vectors describing the column name in `data` where the information is found.

### Arguments 

**data** - is a data.frame containing your data. Data is optional if all inputs are done in vector mode where the appropriate vectors are given for geometry, grouping, and time. If inputting vector mode, sftrack creates column names `sft_group`, `sft_timestamp`, and `sft_error` in data frame. Names can be manually changed using `group_name`, `time_name`, and `error_name` and changing `overwrite_names` to FALSE will write over the data if the column already exists in `data`.

**group** (required) - a list with named vectors to group the sftrack. One group must be named `id`, but otherwise can be infinite number of grouping variables. Or a vector naming the column names for each grouping categories. If only one variable is given then that vector is assumed to be the id column.  

**coords** (required) - The x,y,z coordinates to calculate geometries via `sf`. Accepts either a vector of `c(x,y,z)` describing which column the coordinates can be found, or a list(x=, y=, z=) with vectors for each coordinate. z is optional. NAs are allowed, alhough NAs must exist through the entire row otherwise an error is thrown. This is the same argument from `sf` functions and feeds into `st_as_sf()` internally.    

**time** (required) - Time information in either `POSIXct` or as an `integer`. Accepts either a vector of time, or the column name found in `data`. The outputted object will be sorted by the time column.  

**error** - Error information for the associated xyz point. Accepts either a vector of the error, or the column name found in `data`. If not given, default = NA.

**crs** - the coordinate references system/projection of the data, as implemented by rgdal. see ?rgdal::`CRS-class` for more information. If none is supplied crs is set as NA and can be set later using `sf::st_crs()` from `sf`.  

**active_group** (required) - This is a vector containing what groups are 'active'. Meaning calculations and graphing will use these groupings. If no value is supplied it defaults to all grouping variables. Can change active_group later using `active_group() <- 'myvalue'`. 


### Vector inputs

In the case of vector inputs, the vectors are cbinded to `data` if data is supplied. Sftrack returns an error if the column name already exists in the data.frame and `overwrite_names` remains FALSE. Default column names are: group = 'sft_group', time = 'sft_timestamp', error = 'sft_error'. Names can be overwitten using `overwrite_names = TRUE`. At present Geometry defaults as 'Geometry' and at present can be changed later via `sf` but not via `sftrack` as we make a new sf object when we make an sftrack object. 


```{r}
library("sftrack")

## Check raw data
head(raccoons)

## Coordinates and projection
coords <- raccoons[, c("longitude", "latitude")]
crs <- "+init=epsg:4326"
## Grouping
group <- list(id = raccoons$animal_id,
              month = as.POSIXlt(raccoons$timestamp)$mon + 1)
active_group <- c("id", "month")
## Time
time <- raccoons$timestamp
## Error
error <- raccoons$fix
racc_track <- as_sftrack(data = raccoons, coords = coords, group = group, 
                         active_group = active_group, time = time, 
                         crs = crs, error = error)

print(racc_track, 6)

```

As you can see in this case the data is not overwritten, but extra columns added with the correct data.


### `data.frame` inputs

Data.frame inputs generally describe the columns that represent the variables in `data`. If the columns are not found in `data`, an error is returned. 


```{r}
raccoons$month <- as.POSIXlt(raccoons$timestamp)$mon + 1

coords <- c("longitude", "latitude")
group <- c(id = "animal_id", month = "month")
time <- "timestamp"
error <- "fix"

racc_traj <- as_sftraj(data = raccoons, coords = coords, group = group,
                       time = time, error = error)

print(racc_traj, 6)
```


## Conversion mode

`as_sftrack()` and `as_sftraj()` also accept other data types, but the
arguments for each differ depending on the class they're converting
from. They currently accepts, `sf`, `ltraj` (from `adehabitatLT`),
`trackeRdata` (from `trackeR`), and `track_xyt` (from `amt`).


### Import from `adehabitat::ltraj`

To read in an `ltraj` object all you need is an actual `ltraj` object created in `adehabitatLT`. All relevant information is taken from the object. Bursts as defined in an `ltraj` are slightly different than `sftrack`'s groupings, so it assumes the `ltraj` burst is the `id` field of the `sftrack` grouping object.

```{r, message = FALSE}
library("adehabitatLT")

racc_ltraj <- as.ltraj(xy = raccoons[,c("longitude", "latitude")],
                     date = raccoons$timestamp,
                     id = raccoons$animal_id,
                     infolocs = raccoons[,1:6])
racc_from_ltraj <- as_sftrack(racc_ltraj)
print(racc_from_ltraj, 6)

```

### sf objects

`sf` objects are handled similarly as `data.frame` inputs except you do not need to input any information about the coordinates or projection. Grouping and time are still required. The `sf` GEOMETRY must be in an `sfc_POINT` column. 

```{r}
library("sf")
racc_sf <- st_as_sf(raccoons, coords = c("longitude","latitude"),
                    crs = "+init=epsg:4326", remove = FALSE,
                    na.fail = FALSE)
group <- c(id = "animal_id")
time_col <- "timestamp"
print(racc_sf, n = 6)

racc_from_sf <- as_sftraj(racc_sf, group = group, time= time_col) 
print(racc_from_sf, 6)

```


### Intra-package conversion between classes

Additionally `as_sftrack` and `as_sftraj` can convert back and forth between classes with no loss in information.

```{r}
## Convert between types
new_sftrack <- as_sftrack(racc_traj)
new_sftraj <- as_sftraj(racc_track)

identical(racc_traj, new_sftraj)
identical(racc_track, new_sftrack)
```


### Duplicated data

A common issue with movement data is when duplicated gps time stamps are logged for a sensor. When this happens it can be impossible for `sftrack` to know which point to use. For this reason, sftrack returns an error if any `grouping` + `time` combinations are duplicated. 


```{r}
raccoons$timestamp[1] <- raccoons$timestamp[2]
try(as_sftrack(data = raccoons, coords = coords, group = group, time = time, error = error))

```

To help determine which rows are duplicated you can use the `which_duplicated()` function to check your inputs. After which you can delete the superfluous rows and try again:

```{r}
which_duplicated(data = raccoons , group = group, time = time)
raccoons <- raccoons[-2, ]

coords <- raccoons[, c("longitude", "latitude")]
crs <- "+init=epsg:4326"
group <- list(id = raccoons$animal_id,
              month = as.POSIXlt(raccoons$timestamp)$mon + 1)
active_group <- c("id", "month")
time <- raccoons$timestamp
error <- raccoons$fix
racc_track <- as_sftrack(data = raccoons, coords = coords, group = group, 
                         active_group = active_group, time = time, 
                         crs = crs, error = error)

```
