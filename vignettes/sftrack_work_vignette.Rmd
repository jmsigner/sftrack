---
title: "sftrack working vignette"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include =FALSE}
devtools::load_all("/home/matt/r_programs/sftrack")

```
*This vignette acts as a proto how-to manually mainly for highlighting features for anyone testing sftrack. It will eventually evolve into the full vignette.*

We'll begin with a brief overview of an `sftrack` object:

An `sftrack` object has 4 parts to it, 3 of which are required:  
 - **Geometry** This is stored as an `sfc` object from sf. Accepts x,y,z coordinates.  
 - **Burst** This is the grouping variables, which contains at minimum an id field to identify the subject.  
 - **Time** This can either be a POSIX object or an integer.  
 - **Error** (optional). This is the field with error data in it.  

## Loading in raw data

To read in data we use the `as_sftrack` or `as_sftraj` function, depending on your desired output. Both have the same arguments and output except the way the geometry field is calculated.  

`as_sftrack` accepts 2 kinds of raw data for each of the 4 required parts. Either a vector/list representing the data where length = nrow(data), or it accepts the column name where the data exists. For any `sftrack` component you can input either kind vector data or the column name, but not both. 

#### Global options
These are options that are required regardless of which input type.  

**data** is a data frame. At present we are reserving 'burst' as a column name, so data will be overwritten if this column name exists.  
**crs** the coordinate references system/projection data, as implemented by rgdal. see CRS-class for more information. If none is supplied crs is set as NA and can be set later.  
**active_burst** This is a vector containing what bursts are 'active'. Meaning calculations and graphing will be grouped by these bursts. Can change active_burst whenever. If no value is supplied it defaults to all bursts.  

### Vector inputs
Vector inputs are generally feeding as_sftrack the data itself where length(vector) == nrow(data). Or a list where each component adheres to this rule.  

**burst_list** a list with named vectors to group the sftrack where each list item is length(vector) = nrow(data). One item must be named `id`, but otherwise can be feature infinite number of grouping variables.  
**xyz** data.frame of x,y,z coordinates where column with order : `c(x, y, z)`, z is optional. NAs are allowed, alhough NAs must exist through the entire row otherwise an error is thrown.  
**time** a vector containing the time information, must be either POSIX or an integer where length(time) == nrow(data). Using this argument will name the time column as 'reloc_time'.  
**error** a vector containing the error information where length(error) == nrow(data). Using this argument will name the error information as 'track_error'. Input can be singular NA, inwhich the column is filled with NAs.  

### Examples (Vector)

```{r}
data("raccoon_data")

#data
data = raccoon_data
#xyz
xyz = data[,c('longitude','latitude')]
crs = '+init=epsg:4326'
#bursts
burst_list = list(id = raccoon_data$sensor_code,month = as.POSIXlt(raccoon_data$utc_date)$mon+1)
active_burst = c('id','month')
#time
time = as.POSIXct(raccoon_data$acquisition_time, tz='EST')
#error
error = data$fix
my_sftrack <- as_sftrack(data = data, xyz = xyz, burst_list = burst_list, 
                         active_burst = active_burst, time = time, 
                         crs = crs, error = error)

head(my_sftrack)

```

As you can see in this case the data is not overwritten, but extra columns added with the correct data.

-------------

### data.frame inputs  
Data.frame inputs generally just describe the columns in the data that represent each field.  

**coords** a vector listing the column names for each x,y,z coordinate, just like `sf`, where again position 1 = x, 2 = y, 3 = z. ex: `c('longitude','latitude','altitude')`.  
**id** a character string naming the column with the id information.  
**burst_col** a vector with character strings naming additional burst information. This field is not required, and should not contain the `id` field.  
**time_col** a character string naming the column with the time information. Must be POSIX or integer.  
**error_col** a character string naming the column with the error information. If NA, error column is stored as NA and not accessible.  

### Examples (data.frame inputs)

```{r}
data$time <- as.POSIXct(data$acquisition_time, tz='EST')
data$month <- as.POSIXlt(data$acquisition_time)$mon+1

coords = c('longitude','latitude')
id = 'sensor_code'
burst_col = c('month')
time_col = 'time'
error_col = 'fix'

my_sftraj <- as_sftraj(data = data, coords = coords, id = id, burst_col = burst_col, time_col = time_col, error_col = error_col)

head(my_sftraj)
```

## Conversion mode

`as_sftrack` and `as_sftraj` also accept other data types, and the arguments differ depending on the class. It currenly accepts, `sf`, `ltraj`, and eventually `tibbles`. 

### Import from ltraj
For an ltraj all you need is the ltraj object, all relevant information is taken from the object. As crs information is not allowed in ltraj objects, you may also supply the crs.  

```{r, message = FALSE}
library(adehabitatLT)

ltraj_df <- as.ltraj(xy=raccoon_data[,c('longitude','latitude')], date = as.POSIXct(raccoon_data$acquisition_time),
 id = raccoon_data$sensor_code, typeII = TRUE,
 infolocs = raccoon_data[,1:6] )

my_sf <- as_sftrack(ltraj_df, crs = crs)
head(my_sf)


```

### sf objects
`sf` objects are handled similiarly to the standard raw data, except you do not need to input any information about the coordinates.

```{r}
library(sf)
df1 <- data[!is.na(raccoon_data$latitude),]
sf_df <- st_as_sf(df1, coords=c('longitude','latitude'), crs = crs)
id = 'sensor_code'
time_col = 'time'

new_sftraj <- as_sftraj(sf_df,id=id, time_col = time_col) 
head(new_sftraj)

new_sftrack <- as_sftrack(sf_df, id=id, time_col = time_col) 
head(new_sftrack)

```
### Inter-class conversion
Additionally `as_sftrack` and `as_sftraj` can convert back and forth between each other.

```{r}
# Make tracks from raw data
my_sftrack <- as_sftrack(data = data, coords = coords, id = id, burst_col = burst_col, time_col = time_col, error_col = error_col)
my_sftraj <- as_sftraj(data = data, coords = coords, id = id, burst_col = burst_col, time_col = time_col, error_col = error_col)

# Convert between types
new_sftrack <- as_sftrack(my_sftraj)
#head(new_sftrack)
new_sftraj <- as_sftraj(my_sftrack)
#head(new_sftraj)

all.equal(my_sftraj,new_sftraj)
all.equal(my_sftrack,new_sftrack)
```

### Some basic functionality of sf_track and sf_traj objects
**print**  
`print()` prints out the type of object as well as specific data on the sf_track object. Additionally you can supply the number of rows or columns you'd like to display with arguments `n_row` and `n_col`. When using `n_col` the display will show the `burst` and `geometery` fields as well as any other columns starting from column 1 until `#columns + 2 = n_col`.
```{r}
print(my_sftrack,5,10)
```

**summary**  
`summary()` works as youd normally expect for a data.frame, except displays the burst column as a count of each active_burst combination.  
```{r}
summary(my_sftrack)
```

**summary_sftrack**  
`summary_sftrack()` is a special summary function specific for sftrack objects. It summarizes the data based on the beginning and end of each burst as well as the total distance of the burst. This function uses `st_length` from the `sf` package and therefore outputs in units of the crs. In this example the distance is in degrees distance.
```{r}
summary_sftrack(my_sftrack)

```

You can also trigger this function by using `summary(data, stats = TRUE)`

```{r}
summary(my_sftrack, stats = TRUE)
```
## Plotting

**Base plotting**  
Currently there are some basic plotting methods. Base plotting currently does not have any thrills built into it, and assumes that the `active_burst` is the grouping/coloring variable.  


```{r}
plot(my_sftraj)
```

**ggplot**  
This is a work in progress, but theres a rudimentary geom_sftrack function. As of now you have to input `data` into the geom_sftrack function. That'll change once I figure it out. Again ggplot assumes active_burst is the grouping variable. Plots vary slightly based on if they're track of traj

```{r}
library(ggplot2)
ggplot() + geom_sftrack(data = my_sftraj)
```

## Bursts  

Bursts are a big point in the class. They are made in a similar vein to the `sfc` and `sfg` in `sf`. `ind_burst` is a singular birst. Its whats stored at the row level. 
A `multi-burst` is a collection of `ind_bursts` and exists at the column level. Bursts also have an `active_burst` argument, which turns on and off certain bursts for analysis and plotting purposes.

We can look at the structure
```{r}
mb1 <- make_multi_burst(burst_list=burst_list, active_burst=c('id','month'))
str(mb1)
mb1[[1]]
```
A burst contains grouping information, where the id of the subject is required, but additional bursts are not. Every burst also has the same active_burst columns, and these bursts are stored internally as a list. You can also see that labels are created based on the active_burst, this can be accessed and makes for easy labeling of plots of figures.  

#### Basics
**ind_bursts**  
An ind_burst is the grouping variables for a single row of data.  

Each burst internally makes a label which is just a `paste(., sep='_')`, and gets recalculated when a burst changes. You can make an `ind_burst` object using `make_ind_burst()`, and giving it a list with the bursts named, as well as indicating the active_burst. If you leave it blank it will assume its all bursts

```{r}

indb <- make_ind_burst(list(id='CJ13', month = 4), active_burst='id')
indb
active_burst(indb)

indb <- make_ind_burst(list(id='CJ13', month = 4))
active_burst(indb)
```

**multi_burst**  
Multi_bursts are a collection of ind_bursts, where all ind_bursts must have the same grouping variables and same active_burst. 

Similarly to ind_burst you can make a multi_burst with `make_multi_burst()`. The argument `burst_list` takes a list where each element is a vector indicating the burst as well as a vector of the active bursts.

```{r}
burst_list <- list(id = rep(1:2,10), year = rep(2020, 10))
mb <- make_multi_burst(burst_list=burst_list, active_burst=c('id','year'))
str(mb)
```

You can also make a multi_burst by concatenating multiple ind_bursts

```{r}
a <- ind_burst(list(id = 1, year = 2020))
b <- ind_burst(list(id = 1, year = 2021))
c <- ind_burst(list(id = 2, year = 2020))
mb <- c(a, b , c)

summary(mb)
```

You can also edit bursts like a list, but you must replace it with an object of the appropriate class
```{r}
mb[1]
mb[1] <- make_ind_burst(list(id=3,year=2019))
mb[1]

```

And the burst names must match the ones in the multi_burst
```{r}
# Try to add an ind_burst with a month field when the original burst had year instead 
tryCatch(mb[1] <- make_ind_burst(list(id=3,month=2019)), error = function(e) e)
```

You can also edit individual elements in an ind_burst
```{r}
indb 
indb[1] <- 'CJ15'
str(indb)
```

You can also view and change the active_burst with `active_burst`.

```{r}
active_burst(indb)
active_burst(indb) <- c('id')
str(indb)
```

### Addtional burst functions
There are a handful of other additional burst functions, most of which are just used internally, but could be useful to developers.

**burst_select**
`Burst_select` allows you select only the bursts that are active. 

```{r}
burst_select(mb1)[1:3]
```

**burst_labels**  
burst labels allows access to the burst labels which are a combination of the active bursts with '_' seperator

```{r}
burst_labels(mb1)[1:10]
```

**burst_sort**  
Bursts also have an internal sorting index, that can be used to quickly order data or to quickly search through it. It is calculated based on burst labels (alphabetically) and then by time. It gets recalculated everytime a new multi_burst is made or modified, so it is reliable. You can access it with `burst_sort`, but you can not modify it, as it is calculated internally.  

This is stored as a factor so it can double as burst_labels as well as an integer when necessary.

```{r}
burst_sort(mb1)[1:10]
```

On occasion your data may have more possible burst levels than are available in the current data frame, and you would like this data to be preserved. Because of this we allow burst_levels to be amended to add more levels than are in the current data. Since this variable is a factor, we simply are redefining the factor levels with `burst_levels`. This may also be useful if you'd like to rearrange the order of plotting.

```{r}
burst_levels(mb1)
burst_levels(mb1) <- c("CJ11_1", "CJ11_2", "CJ13_1" ,"CJ13_2", "CJ14_3")
burst_levels(mb1)
```

## Geometry column  

The geometry column of an sf_track object is a `sfc` column from the `sf` package. And therefore it can be manipulated exactly like you would in `sf` with the entirety of the `sf` packages functions. The main difference is that we automatically allow empty geometries, where as this option is turned off by default in `st_as_sf()`.
```{r}
my_sftrack$geometry
```

An `sftrack` object is simply an `sfc` of `sf_POINTS`, this contrasts with an `sftraj` object which is a mixture of a geometrycollection and linestring. This is because a trajectory can have a start point and an NA end point, a line segment, or an NA and an end point. This allows no-loss conversion back and forth between `sftrack` and an `sftraj`, and because linestrings can not have a NULL point in them.

```{r}
my_sftraj$geometry
```

This does mean that not all `sf` functions will handle an `sftraj` object like it would an `sftrack` if there are NAs in the data set. To help this, there are two functions that help extract points from `sftraj` objects.

**coord_traj**  
This function returns a data.frame (x,y,z) of the beginning point of each sftraj geometry.

```{r}
coord_traj(my_sftraj$geometry)[1:10,]
```

**pts_traj**  
And `pts_traj` returns a list of the beginning point of each sftraj geometry

**is_linestring**  
Returns TRUE or FALSE if the geometry is a linestring. This allows you to filter an `sftraj` object to be 'pure'.

```{r}
is_linestring(my_sftraj$geometry)[1:10]

```
